
import os
import re
import json
import shlex
import traceback
import warnings


import collections
from bs4 import FeatureNotFound
from bs4.builder import (
    builder_registry,
    ParserRejectedMarkup
)
from bs4.element import (
    DEFAULT_OUTPUT_ENCODING,
    NavigableString,
    Tag,
)


def build_html(d, depth=1):
    """ Build HTML string from dict"""
    html = ''
    if isinstance(d, dict):
        for k in d:
            l_s = '&nbsp;' * depth * 2
            l_b = '<br/>' if isinstance(d[k], (dict, tuple, list)) else ''
            html += '{l_s}<label>{k}: </label>{l_b}<{k}>{v}</{k}><br/>'.format(
                l_s=l_s, l_b=l_b, k=k, v=build_html(d[k], depth=depth + 1)
            )
    elif isinstance(d, (list, tuple)):
        for item in d:
            html += '{}<br/>'.format(build_html(item, depth=depth + 1))
    else:
        html += str(d)
    return html


class CTag(Tag):
    """ Select(selector)
    Normal: 
        - ``tr:nth-of-type(1) > td:nth-of-type(1)``;

    Customized:
        - Text: 
            ``tr:text=[name] > td:n(2)``
            Same as:  ``tr:text=["name"] > td:nth-of-type(2)``
        - Cut off: 
            ``div.content > b:text=["first\\ line"] < b:text=["second\\ line"]``
            This will select content between ``b:text=["second\\ line"]``
            and ``b:text=["first\\ line"]`` **in** ``div.content`` 

    **NOTE:** 
        To handle special symbols: 
        - Space must escape like ``"\\ "``, 
            For example, ``div:text=["name"] > b:text=["content\\ detail"]``;
    """

    def select(self, selector, _candidate_generator=None, limit=None,
               strict=False):
        """ Perform a CSS selection operation on the current element."""

        # Handle grouping selectors if ',' exists, ie: p,a
        if ',' in selector:
            context = []
            for partial_selector in selector.split(','):
                partial_selector = partial_selector.strip()
                if partial_selector == '':
                    raise ValueError \
                        ('Invalid group selection syntax: %s' % selector)
                candidates = self.select(partial_selector, limit=limit)
                for candidate in candidates:
                    if candidate not in context:
                        context.append(candidate)

                if limit and len(context) >= limit:
                    break
            return context

        tokens = shlex.split(selector)
        current_context = [self]

        if tokens[-1] in self._selector_combinators:
            raise ValueError(
                'Final combinator "%s" is missing an argument.' % tokens[-1])

        if self._select_debug:
            print('Running CSS selector "%s"' % selector)

        for index, token in enumerate(tokens):
            new_context = []
            new_context_ids = set([])

            if tokens[index - 1] in self._selector_combinators:
                # This token was consumed by the previous combinator. Skip it.
                if self._select_debug:
                    print('  Token was consumed by the previous combinator. %s'
                          % tokens[index - 1])
                continue
            if tokens[index - 1] == '<':
                if self._select_debug:
                    print('  Token was Rollbacked. %s' % tokens[index])
                continue

            if self._select_debug:
                print(' Considering token "%s"' % token)
            recursive_candidate_generator = None
            until_sibling_generator = None
            tag_name = None

            # Each operation corresponds to a checker function, a rule
            # for determining whether a candidate matches the
            # selector. Candidates are generated by the active
            # iterator.
            checker = None

            m = self.attribselect_re.match(token)
            if m is not None:
                # Attribute selector
                tag_name, attribute, operator, value = m.groups()
                checker = self._attribute_checker(operator, attribute, value)

            elif '#' in token:
                # ID selector
                tag_name, tag_id = token.split('#', 1)
                def id_matches(tag):
                    return tag.get('id', None) == tag_id
                checker = id_matches

            elif '.' in token:
                # Class selector
                tag_name, klass = token.split('.', 1)
                classes = set(klass.split('.'))
                def classes_match(candidate):
                    return classes.issubset(candidate.get('class', []))
                checker = classes_match

            elif ':' in token and not self.quoted_colon.search(token):
                # Pseudo-class
                tag_name, pseudo = token.split(':', 1)
                if tag_name == '':
                    raise ValueError(
                        "A pseudo-class must be prefixed with a tag name.")
                pseudo_attributes = re.match(
                    '([a-zA-Z\d-]+)(?:=\[(.*)\])?(?:\(([a-zA-Z\d]+)\))?',
                    pseudo
                )
                if pseudo_attributes is None:
                    pseudo_type, pseudo_text, pseudo_value = pseudo, None, None
                else:
                    pseudo_type, pseudo_text, pseudo_value = \
                        pseudo_attributes.groups()

                if pseudo_type in {'text'}:
                    if not pseudo_text:
                        raise ValueError('Text illegal')

                    def find_text(tag):
                        text = re.compile \
                            (pseudo_text) if not strict else pseudo_text
                        return tag.find(text=text) is not None
                    checker = find_text
                elif pseudo_type in {'nth-of-type', 'n', 'nth-of-child'}:
                    try:
                        pseudo_value = int(pseudo_value)
                    except:
                        raise NotImplementedError(
                            'Only numeric values are currently supported for '
                            'the nth-of-type pseudo-class.')
                    if pseudo_value < 1:
                        raise ValueError(
                            'nth-of-type pseudo-class value must be at least '
                            '1.')

                    class Counter(object):
                        def __init__(self, destination):
                            self.count = 0
                            self.destination = destination

                        def nth_child_of_type(self, tag):
                            self.count += 1
                            if self.count == self.destination:
                                return True
                            return False
                    checker = Counter(pseudo_value).nth_child_of_type
                else:
                    raise ValueError(
                        'Only allowed pseudo-classes of: '
                        '[nth-of-type, nth-of-child, n, text]')
            elif token == '*':
                # Star selector -- matches everything
                pass
            elif token == '>':
                # Run the next token as a CSS selector against the
                # direct children of each tag in the current context.
                recursive_candidate_generator = lambda tag: tag.children
            elif token == '~':
                # Run the next token as a CSS selector against the
                # siblings of each tag in the current context.
                recursive_candidate_generator = lambda tag: tag.next_siblings
            elif token == '+':
                # For each tag in the current context, run the next
                # token as a CSS selector against the tag's next
                # sibling that's a tag.
                def next_tag_sibling(tag):
                    yield tag.find_next_sibling(True)
                recursive_candidate_generator = next_tag_sibling
            elif token == '<':
                stop_token = tokens[index + 1]

                def until_sibling(tag):
                    stop_id = id(self.select_one(stop_token))
                    start_sibling = current_context
                        [0] if current_context else tag
                    for _sibling in start_sibling.next_siblings:
                        if self._select_debug:
                            print( '_' *5, _sibling, '_'* 5)
                        if id(_sibling) == stop_id:
                            raise StopIteration()
                        yield _sibling

                until_sibling_generator = until_sibling
            elif self.tag_name_re.match(token):
                # Just a tag name.
                tag_name = token
            else:
                raise ValueError(
                    'Unsupported or invalid CSS selector: "%s"' % token)
            if recursive_candidate_generator:
                # This happens when the selector looks like  "> foo".
                #
                # The generator calls select() recursively on every
                # member of the current context, passing in a different
                # candidate generator and a different selector.
                #
                # In the case of "> foo", the candidate generator is
                # one that yields a tag's direct children (">"), and
                # the selector is "foo".
                next_token = tokens[index + 1]

                def recursive_select(tag):
                    if self._select_debug:
                        print(
                            '    Calling select("%s") recursively on %s %s' % (
                            next_token, tag.name, tag.attrs))
                        print('-' * 40)
                    for i in tag.select(next_token,
                                        recursive_candidate_generator):
                        if self._select_debug:
                            print(
                                '(Recursive select picked up candidate %s '
                                '%s)' % (
                                i.name, i.attrs))
                        yield i
                    if self._select_debug:
                        print('-' * 40)

                _use_candidate_generator = recursive_select
            elif until_sibling_generator:
                _use_candidate_generator = until_sibling_generator
            elif _candidate_generator is None:
                # By default, a tag's candidates are all of its
                # children. If tag_name is defined, only yield tags
                # with that name.
                if self._select_debug:
                    if tag_name:
                        check = "[any]"
                    else:
                        check = tag_name
                    print(
                        '   Default candidate generator, tag name="%s"' % check)
                if self._select_debug:
                    # This is redundant with later code, but it stops
                    # a bunch of bogus tags from cluttering up the
                    # debug log.
                    def default_candidate_generator(tag):
                        for child in tag.descendants:
                            if not isinstance(child, Tag):
                                continue
                            if tag_name and not child.name == tag_name:
                                continue
                            yield child

                    _use_candidate_generator = default_candidate_generator
                else:
                    _use_candidate_generator = lambda tag: tag.descendants
            else:
                _use_candidate_generator = _candidate_generator

            for tag in current_context:
                if self._select_debug:
                    print("    Running candidate generator on %s" % (
                        tag.name))
                for candidate in _use_candidate_generator(tag):
                    if until_sibling_generator:
                        new_context.append(candidate)
                        new_context_ids.add(id(candidate))
                    if not isinstance(candidate, Tag):
                        continue
                    if tag_name and candidate.name != tag_name:
                        continue
                    if checker is not None:
                        try:
                            result = checker(candidate)
                        except StopIteration:
                            # The checker has decided we should no longer
                            # run the generator.
                            break
                    if checker is None or result:
                        if self._select_debug:
                            print("     SUCCESS %s %s" % (
                            candidate.name, repr(candidate.attrs)))
                        if id(candidate) not in new_context_ids:
                            # If a tag matches a selector more than once,
                            # don't include it in the context more than once.
                            new_context.append(candidate)
                            new_context_ids.add(id(candidate))
                    elif self._select_debug:
                        print("     FAILURE %s %s" % (
                        candidate.name, repr(candidate.attrs)))

            if until_sibling_generator:
                p = UglySoup('<p></p>', 'html5lib').p
                for x in new_context:
                    p.append(x)
                new_context = [p]
            current_context = new_context
        if limit and len(current_context) >= limit:
            current_context = current_context[:limit]

        if self._select_debug:
            print("Final verdict:")
            for i in current_context:
                print(" %s" % i.name)
        return current_context


class UglySoup(CTag):
    """ This Class is a Customized bs4 soup 
    bs4.BeautifulSoup -> More ugly details 
    """
    ROOT_TAG_NAME = '[document]'

    # If the end-user gives no indication which tree builder they
    # want, look for one with these features.
    DEFAULT_BUILDER_FEATURES = ['html', 'fast']

    ASCII_SPACES = '\x20\x0a\x09\x0c\x0d'

    NO_PARSER_SPECIFIED_WARNING = "No parser was explicitly specified, " \
                                  "so I'm using the best available %(" \
                                  "markup_type)s parser for this system (\"%(" \
                                  "parser)s\"). This usually isn't a problem, " \
                                  "" \
                                  "but if you run this code on another " \
                                  "system, or in a different virtual " \
                                  "environment, it may use a different parser " \
                                  "" \
                                  "and behave differently.\n\nThe code that " \
                                  "caused this warning is on line %(" \
                                  "line_number)s of the file %(filename)s. To " \
                                  "" \
                                  "get rid of this warning, change code that " \
                                  "looks like this:\n\n BeautifulSoup([your " \
                                  "markup])\n\nto this:\n\n BeautifulSoup([" \
                                  "your markup], \"%(parser)s\")\n"

    def __init__(self, markup="", features=None, builder=None,
                 parse_only=None, from_encoding=None,
                 exclude_encodings=None,
                 **kwargs):
        """The Soup object is initialized as the 'root tag', and the
        provided markup (which can be a string or a file-like object)
        is fed into the underlying parser."""

        if 'convertEntities' in kwargs:
            warnings.warn(
                "BS4 does not respect the convertEntities argument to the "
                "BeautifulSoup constructor. Entities are always converted "
                "to Unicode characters.")

        if 'markupMassage' in kwargs:
            del kwargs['markupMassage']
            warnings.warn(
                "BS4 does not respect the markupMassage argument to the "
                "BeautifulSoup constructor. The tree builder is responsible "
                "for any necessary markup massage.")

        if 'smartQuotesTo' in kwargs:
            del kwargs['smartQuotesTo']
            warnings.warn(
                "BS4 does not respect the smartQuotesTo argument to the "
                "BeautifulSoup constructor. Smart quotes are always converted "
                "to Unicode characters.")

        if 'selfClosingTags' in kwargs:
            del kwargs['selfClosingTags']
            warnings.warn(
                "BS4 does not respect the selfClosingTags argument to the "
                "BeautifulSoup constructor. The tree builder is responsible "
                "for understanding self-closing tags.")

        if 'isHTML' in kwargs:
            del kwargs['isHTML']
            warnings.warn(
                "BS4 does not respect the isHTML argument to the "
                "BeautifulSoup constructor. Suggest you use "
                "features='lxml' for HTML and features='lxml-xml' for "
                "XML.")

        def deprecated_argument(old_name, new_name):
            if old_name in kwargs:
                warnings.warn(
                    'The "%s" argument to the BeautifulSoup constructor '
                    'has been renamed to "%s."' % (old_name, new_name))
                value = kwargs[old_name]
                del kwargs[old_name]
                return value
            return None

        parse_only = parse_only or deprecated_argument(
            "parseOnlyThese", "parse_only")

        from_encoding = from_encoding or deprecated_argument(
            "fromEncoding", "from_encoding")

        if from_encoding and isinstance(markup, str):
            warnings.warn(
                "You provided Unicode markup but also provided a value for "
                "from_encoding. Your from_encoding will be ignored.")
            from_encoding = None

        if len(kwargs) > 0:
            arg = list(kwargs.keys()).pop()
            raise TypeError(
                "__init__() got an unexpected keyword argument '%s'" % arg)

        if builder is None:
            original_features = features
            if isinstance(features, str):
                features = [features]
            if features is None or len(features) == 0:
                features = self.DEFAULT_BUILDER_FEATURES
            builder_class = builder_registry.lookup(*features)
            if builder_class is None:
                raise FeatureNotFound(
                    "Couldn't find a tree builder with the features you "
                    "requested: %s. Do you need to install a parser library?"
                    % ",".join(features))
            builder = builder_class()
            if not (original_features == builder.NAME or
                            original_features in builder.ALTERNATE_NAMES):
                if builder.is_xml:
                    markup_type = "XML"
                else:
                    markup_type = "HTML"

                caller = traceback.extract_stack()[0]
                filename = caller[0]
                line_number = caller[1]
                warnings.warn(self.NO_PARSER_SPECIFIED_WARNING % dict(
                    filename=filename,
                    line_number=line_number,
                    parser=builder.NAME,
                    markup_type=markup_type))

        self.builder = builder
        self.is_xml = builder.is_xml
        self.known_xml = self.is_xml
        self.builder.soup = self

        self.parse_only = parse_only

        if hasattr(markup, 'read'):  # It's a file-type object.
            markup = markup.read()
        elif len(markup) <= 256 and (
                    (isinstance(markup, bytes) and not b'<' in markup)
                or (isinstance(markup, str) and not '<' in markup)
        ):
            # Print out warnings for a couple beginner problems
            # involving passing non-markup to Beautiful Soup.
            # Beautiful Soup will still parse the input as markup,
            # just in case that's what the user really wants.
            if (isinstance(markup, str)
                and not os.path.supports_unicode_filenames):
                possible_filename = markup.encode("utf8")
            else:
                possible_filename = markup
            is_file = False
            try:
                is_file = os.path.exists(possible_filename)
            except Exception as e:
                # This is almost certainly a problem involving
                # characters not valid in filenames on this
                # system. Just let it go.
                pass
            if is_file:
                if isinstance(markup, str):
                    markup = markup.encode("utf8")
                warnings.warn(
                    '"%s" looks like a filename, not markup. You should'
                    'probably open this file and pass the filehandle into'
                    'Beautiful Soup.' % markup)
            self._check_markup_is_url(markup)

        for (
                self.markup, self.original_encoding,
                self.declared_html_encoding,
                self.contains_replacement_characters) in (
                self.builder.prepare_markup(
                    markup, from_encoding,
                    exclude_encodings=exclude_encodings)):
            self.reset()
            try:
                self._feed()
                break
            except ParserRejectedMarkup:
                pass

        # Clear out the markup and remove the builder's circular
        # reference to this object.
        self.markup = None
        self.builder.soup = None

    def __copy__(self):
        copy = type(self)(
            self.encode('utf-8'), builder=self.builder,
            from_encoding='utf-8'
        )

        # Although we encoded the tree to UTF-8, that may not have
        # been the encoding of the original markup. Set the copy's
        # .original_encoding to reflect the original object's
        # .original_encoding.
        copy.original_encoding = self.original_encoding
        return copy

    def __getstate__(self):
        # Frequently a tree builder can't be pickled.
        d = dict(self.__dict__)
        if 'builder' in d and not self.builder.picklable:
            d['builder'] = None
        return d

    @staticmethod
    def _check_markup_is_url(markup):
        """ 
        Check if markup looks like it's actually a url and raise a warning 
        if so. Markup can be unicode or str (py2) / bytes (py3).
        """
        if isinstance(markup, bytes):
            space = b' '
            cant_start_with = (b"http:", b"https:")
        elif isinstance(markup, str):
            space = ' '
            cant_start_with = ("http:", "https:")
        else:
            return

        if any(markup.startswith(prefix) for prefix in cant_start_with):
            if not space in markup:
                if isinstance(markup, bytes):
                    decoded_markup = markup.decode('utf-8', 'replace')
                else:
                    decoded_markup = markup
                warnings.warn(
                    '"%s" looks like a URL. Beautiful Soup is not an'
                    ' HTTP client. You should probably use an HTTP client like'
                    ' requests to get the document behind the URL, and feed'
                    ' that document to Beautiful Soup.' % decoded_markup
                )

    def _feed(self):
        # Convert the document to Unicode.
        self.builder.reset()

        self.builder.feed(self.markup)
        # Close out any unfinished strings and close all the open tags.
        self.endData()
        while self.currentTag.name != self.ROOT_TAG_NAME:
            self.popTag()

    def reset(self):
        CTag.__init__(self, self, self.builder, self.ROOT_TAG_NAME)
        self.hidden = 1
        self.builder.reset()
        self.current_data = []
        self.currentTag = None
        self.tagStack = []
        self.preserve_whitespace_tag_stack = []
        self.pushTag(self)

    def new_tag(self, name, namespace=None, nsprefix=None, **attrs):
        """Create a new tag associated with this soup."""
        return CTag(None, self.builder, name, namespace, nsprefix, attrs)

    def new_string(self, s, subclass=NavigableString):
        """Create a new NavigableString associated with this soup."""
        return subclass(s)

    def insert_before(self, successor):
        raise NotImplementedError(
            "BeautifulSoup objects don't support insert_before().")

    def insert_after(self, successor):
        raise NotImplementedError(
            "BeautifulSoup objects don't support insert_after().")

    def popTag(self):
        tag = self.tagStack.pop()
        if self.preserve_whitespace_tag_stack and tag == \
                self.preserve_whitespace_tag_stack[-1]:
            self.preserve_whitespace_tag_stack.pop()
        # print "Pop", tag.name
        if self.tagStack:
            self.currentTag = self.tagStack[-1]
        return self.currentTag

    def pushTag(self, tag):
        # print "Push", tag.name
        if self.currentTag:
            self.currentTag.contents.append(tag)
        self.tagStack.append(tag)
        self.currentTag = self.tagStack[-1]
        if tag.name in self.builder.preserve_whitespace_tags:
            self.preserve_whitespace_tag_stack.append(tag)

    def endData(self, containerClass=NavigableString):
        if self.current_data:
            current_data = ''.join(self.current_data)
            # If whitespace is not preserved, and this string contains
            # nothing but ASCII spaces, replace it with a single space
            # or newline.
            if not self.preserve_whitespace_tag_stack:
                strippable = True
                for i in current_data:
                    if i not in self.ASCII_SPACES:
                        strippable = False
                        break
                if strippable:
                    if '\n' in current_data:
                        current_data = '\n'
                    else:
                        current_data = ' '

            # Reset the data collector.
            self.current_data = []

            # Should we add this string to the tree at all?
            if self.parse_only and len(self.tagStack) <= 1 and \
                    (not self.parse_only.text or \
                             not self.parse_only.search(current_data)):
                return

            o = containerClass(current_data)
            self.object_was_parsed(o)

    def object_was_parsed(self, o, parent=None, most_recent_element=None):
        """Add an object to the parse tree."""
        parent = parent or self.currentTag
        previous_element = most_recent_element or self._most_recent_element

        next_element = previous_sibling = next_sibling = None
        if isinstance(o, Tag):
            next_element = o.next_element
            next_sibling = o.next_sibling
            previous_sibling = o.previous_sibling
            if not previous_element:
                previous_element = o.previous_element

        o.setup(parent, previous_element, next_element, previous_sibling,
                next_sibling)

        self._most_recent_element = o
        parent.contents.append(o)

        if parent.next_sibling:
            # This node is being inserted into an element that has
            # already been parsed. Deal with any dangling references.
            index = len(parent.contents) - 1
            while index >= 0:
                if parent.contents[index] is o:
                    break
                index -= 1
            else:
                raise ValueError(
                    "Error building tree: supposedly %r was inserted "
                    "into %r after the fact, but I don't see it!" % (
                        o, parent
                    )
                )
            if index == 0:
                previous_element = parent
                previous_sibling = None
            else:
                previous_element = previous_sibling = parent.contents[
                    index - 1]
            if index == len(parent.contents) - 1:
                next_element = parent.next_sibling
                next_sibling = None
            else:
                next_element = next_sibling = parent.contents[index + 1]

            o.previous_element = previous_element
            if previous_element:
                previous_element.next_element = o
            o.next_element = next_element
            if next_element:
                next_element.previous_element = o
            o.next_sibling = next_sibling
            if next_sibling:
                next_sibling.previous_sibling = o
            o.previous_sibling = previous_sibling
            if previous_sibling:
                previous_sibling.next_sibling = o

    def _popToTag(self, name, nsprefix=None, inclusivePop=True):
        """Pops the tag stack up to and including the most recent
        instance of the given tag. If inclusivePop is false, pops the tag
        stack up to but *not* including the most recent instqance of
        the given tag."""
        # print "Popping to %s" % name
        if name == self.ROOT_TAG_NAME:
            # The BeautifulSoup object itself can never be popped.
            return

        most_recently_popped = None

        stack_size = len(self.tagStack)
        for i in range(stack_size - 1, 0, -1):
            t = self.tagStack[i]
            if (name == t.name and nsprefix == t.prefix):
                if inclusivePop:
                    most_recently_popped = self.popTag()
                break
            most_recently_popped = self.popTag()

        return most_recently_popped

    def handle_starttag(self, name, namespace, nsprefix, attrs):
        """Push a start tag on to the stack.

        If this method returns None, the tag was rejected by the
        SoupStrainer. You should proceed as if the tag had not occurred
        in the document. For instance, if this was a self-closing tag,
        don't call handle_endtag.
        """

        # print "Start tag %s: %s" % (name, attrs)
        self.endData()

        if (self.parse_only and len(self.tagStack) <= 1
            and (self.parse_only.text
                 or not self.parse_only.search_tag(name, attrs))):
            return None

        tag = CTag(self, self.builder, name, namespace, nsprefix, attrs,
                   self.currentTag, self._most_recent_element)
        if tag is None:
            return tag
        if self._most_recent_element:
            self._most_recent_element.next_element = tag
        self._most_recent_element = tag
        self.pushTag(tag)
        return tag

    def handle_endtag(self, name, nsprefix=None):
        # print "End tag: " + name
        self.endData()
        self._popToTag(name, nsprefix)

    def handle_data(self, data):
        self.current_data.append(data)

    def decode(self, pretty_print=False,
               eventual_encoding=DEFAULT_OUTPUT_ENCODING,
               formatter="minimal"):
        """Returns a string or Unicode representation of this document.
        To get Unicode, pass None for encoding."""

        if self.is_xml:
            # Print the XML declaration
            encoding_part = ''
            if eventual_encoding != None:
                encoding_part = ' encoding="%s"' % eventual_encoding
            prefix = '<?xml version="1.0"%s?>\n' % encoding_part
        else:
            prefix = ''
        if not pretty_print:
            indent_level = None
        else:
            indent_level = 0
        return prefix + super(UglySoup, self).decode(
            indent_level, eventual_encoding, formatter)


class JSONSoup(UglySoup):
    """ JSON Soup 

    For JSONParser, make use of csselector helper and parse JSON like an html

    >>> _json = ''{"data": {"info": "Made in Abyss"}}''
    >>> soup = JSONSoup(_json, 'html5lib')
    >>> soup.select('data > info')
       [<info>Made in Abyss</info>]
    >>> soup.select('data > info')[0].get_text()
        "Made in Abyss"
    """

    def __init__(self, _json, features=None, builder=None,
                 parse_only=None, from_encoding=None,
                 exclude_encodings=None,
                 **kwargs):
        html = self.get_html(_json)
        super(JSONSoup, self).__init__(
            html, features, builder, parse_only, from_encoding,
            exclude_encodings, **kwargs
        )

    def get_obj(self, _json):
        obj_pairs_hook = collections.OrderedDict

        if isinstance(_json, str):
            return json.loads(_json, object_pairs_hook=obj_pairs_hook)
        if isinstance(_json, bytes):
            return json.loads(
                _json.decode('utf-8'), object_pairs_hook=obj_pairs_hook)
        return _json

    def get_html(self, _json):
        obj = self.get_obj(_json)
        return build_html(obj)

    def insert_before(self, successor):
        pass

    def insert_after(self, successor):
        pass

